{"version":3,"file":"space-sync-bundle.js","sources":["webpack:///webpack/bootstrap","webpack:///./js/common/confluence/confluence-attachment-async.js","webpack:///./js/common/confluence/confluence-page-async.js","webpack:///./js/common/confluence/confluence-throttle.js","webpack:///./js/common/confluence/content-sync-service.js","webpack:///./js/mainframe/spaceSyncPlugin.js","webpack:///./node_modules/throat/index.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/ywiki-plugins/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./js/mainframe/spaceSyncPlugin.js\");\n","import {throttleRead, throttleWrite} from './confluence-throttle';\n\nconst BASE_URL = '/rest/api/content/';\n\nexport async function cloneAttachment(attachment, targetContainerId) {\n    let targetAttachment = await lookupAttachment(targetContainerId, attachment.title);\n    let targetAttachmentId = targetAttachment ? targetAttachment.id:null;\n    return clone(attachment._links.download, targetContainerId, attachment.title, targetAttachmentId);\n}\n\nasync function lookupAttachment(containerId, attachmentTitle) {\n    let results = await $.get(BASE_URL+`${containerId}/child/attachment?filename=${attachmentTitle}&expand=version,container`);\n    if (results && results.results && results.results.length) {\n        return results.results[0];\n    } else {\n        return null;\n    }\n}\n\nasync function clone(attachmentUrl, targetContainerId, title, /* optional */ targetId) {\n    let blobData = await loadBlob(attachmentUrl);\n    let attachment = await storeBlob(targetContainerId, blobData, title, targetId);\n    if (attachment.results && attachment.results instanceof Array ) {\n        // the attachment API returns an array\n        return attachment.results[0]; \n    } else {\n        return attachment;\n    }\n}\n\n/** \n * ContentId is mandatory when updating an existing attachment, and must be omitted when\n * creating a new attachment.\n */\nasync function storeBlob(containerId, blobData, title, /* optional */ contentId) {\n    let url = BASE_URL;\n    url += containerId;\n    url += '/child/attachment';\n    if (contentId) {\n        url += '/' + contentId + '/data';\n    }\n    let formData = new FormData();\n    formData.append('file', blobData, title);\n    formData.append('minorEdit', 'true');\n    return throttleWrite( () => postBinary(url, formData));\n}\n\n\n\nasync function loadBlob(url) {\n    return throttleRead( () => loadBinary(url) );\n}\n\nasync function postBinary(url, formData) {\n    return new Promise( (resolve, reject) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", url, true);\n        xhr.onerror = reject;\n        xhr.setRequestHeader('X-Atlassian-Token','nocheck');\n        xhr.onload = function (e) {\n            if (this.status == 200) {\n                resolve(this.response);\n            } else {\n                reject(`Could not POST to ${url}: ${this.status} ${this.statusText}, details: ${this.responseText}`);\n            }\n        };\n        xhr.send(formData);\n    });\n}\nasync function loadBinary(url) {\n    return new Promise( (resolve, reject) => {\n        let xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'blob';\n        xhr.onerror = reject;\n        xhr.onload = function(e) {\n          if (this.status == 200) {\n            // get binary data as a response\n            let blob = this.response;\n            resolve(blob);\n          } else {\n            reject(e);\n          }\n        };\n        xhr.send();\n    });\n}","import {throttleRead, throttleWrite} from './confluence-throttle';\n\nexport async function movePages(sourceSpaceKey, sourcePageTitle,targetSpaceKey, targetParentTitle) {\n  var sourcePage = await getContent(sourceSpaceKey, sourcePageTitle);\n  return await movePagesById( sourcePage.id, targetSpaceKey, targetParentTitle );\n}\nfunction getAtlToken() {\n  return $('meta[name=ajs-atl-token]').attr(\"content\");\n}\n\nexport async function movePagesById (sourcePageId, targetSpaceKey, target) {\n  return await throttleWrite( async () => {\n    let targetParentTitle;\n    if (Number.isInteger(Number(target))) {\n      let targetParent = await getContentById(Number(target));\n      targetParentTitle = targetParent.title;\n    } else {\n      targetParentTitle = target;\n    }\n    if (!targetParentTitle) throw 'targetParentTitle is mandatory (for source '+sourcePageId+' and target '+target+')';\n    var url = '/pages/movepage.action?pageId='+encodeURIComponent(sourcePageId)+'&spaceKey='+encodeURIComponent(targetSpaceKey)+'&targetTitle='+encodeURIComponent(targetParentTitle)+'&position=append&atl_token='+getAtlToken()+'&_='+Math.random();\n    console.log(\"Moving page \",sourcePageId,\" under \",targetSpaceKey+\":\"+ targetParentTitle, url);\n    let resp = await $.ajax(url);\n    if (typeof resp === 'string' && resp.indexOf('Not Permitted'>=0)) {\n      throw 'Not Permitted';\n    } else if (typeof resp === 'string') {\n      throw 'Generic move error';\n    } else if (resp.actionErrors) {\n      throw resp.actionErrors.join();\n    }\n  });\n}\n\n\n\n/**\n* Get a page by spaceKey and title from Confluence and returns a deferred for that page.\n* See $.ajax().done()\n* Failures are logged and ignored.\n* The deferred is resolved with the first matching page is any, else it is rejected.\n*/\nexport async function getContent(spaceKey,pageTitle,expand) {\n  var expandParam=\"\";\n  if (expand) {\n    expandParam = '&expand='+encodeURIComponent(expand);\n  }\n  var url = '/rest/api/content?type=page&spaceKey='+encodeURIComponent(spaceKey)+'&limit=1&title=' + encodeURIComponent(pageTitle) + expandParam;\n  console.log(\"Getting page content from \" + url);\n  var response = await $.ajax(url);\n  console.log(\"Filtering AJAX response\",response);\n  if (response.results && response.results.length>0) {\n    var page = response.results[0];\n    console.log(\"Returning \",page);\n    return page;\n  } else {\n    throw \"Page Not found: '\"+spaceKey+\":\"+pageTitle+\"'\";\n  }\n}\n\nexport async function getContentById(pageId, expand) {\n  var expandParam=\"\";\n  if (expand) {\n    expandParam = '?expand='+encodeURIComponent(expand);\n  }\n  var url = '/rest/api/content/'+encodeURIComponent(pageId) + expandParam;\n  console.log(url);\n  return await $.ajax(url);\n}\n \n/** search for content with CQL\nfor example https://wiki.hybris.com/rest/api/content/search?cql=label=customer%20and%20type=%22page%22%20and%20space=%22ps%22 */\nexport async function searchPagesWithCQL(spaceKey, cqlQuery, limit, expand) {\n  if (!limit || limit<0) {\n    limit=15;\n  }\n  var expandParam=(expand?\"&expand=\"+encodeURIComponent(expand):\"\");\n  return await $.ajax('/rest/api/content/search?limit='+encodeURIComponent(limit)+'&cql='+encodeURIComponent(cqlQuery+' and type=page and space=\\''+spaceKey+'\\'')+expandParam);\n}\n\n/**\n* Copy the page \"fromPageTitle\" (without its descendants) under the page \"toPageTitle\",\n* and do a placeholder replacement the page title using the templateProcessor.\n*/\nexport async function copyPage(fromSpaceKey, fromPageTitle, toSpaceKey, toPageTitle, templateProcessor) {\n  var pageToCopy = await getContent(fromSpaceKey, fromPageTitle, 'space,body.storage,metadata.labels');\n  await templateProcessor.transformPage(pageToCopy);\n  // Create the new page under toPageTitle\n  return await createPage(pageToCopy,toSpaceKey,toPageTitle);\n}\n\nexport async function copyPageToSpace(sourcePageId, targetSpaceKey, targetParentId) {\n  let pageToCopy = await getContentById(sourcePageId, 'space,body.storage,metadata.labels');\n  try {\n    return await getContent(targetSpaceKey, pageToCopy.title);\n    // if it exists, do nothing\n  } catch (err) {\n    // Create the new page \n    return await createPageUnderPageId(pageToCopy,targetSpaceKey,targetParentId);\n  }\n}\n\nexport async function createPageFromTemplate(templateSpace, templateTitle, targetSpaceKey, targetPageId, templateProcessor) {\n  var pageToCopy = await getContent(templateSpace, templateTitle, 'space,body.storage,metadata.labels');\n  //var parentPage = await getContentById(targetPageId, 'space');\n  await templateProcessor.transformPage(pageToCopy);\n  // Create the new page under toPageTitle\n  return await createPageUnderPageId(pageToCopy,targetSpaceKey,targetPageId);\n}\n\nexport async function copyPageRecursive(fromSpaceKey, fromPageTitle, toSpaceKey, toPageTitle, templateProcessor, copiedPages) {\n  var sourcePagePromise = getContent(fromSpaceKey, fromPageTitle);\n  var targetPagePromise = getContent(toSpaceKey,toPageTitle, 'space');\n  var pages = await Promise.all(sourcePagePromise,targetPagePromise);\n  return await copyPageRecursiveInternal( pages[0].id, pages[1].space.key, pages[1].id, templateProcessor, copiedPages);\n}\n\nexport async function copyPageRecursiveInternal(sourcePageId, targetSpaceKey, targetPageId, templateProcessor, copiedPages) {\n  var pageToCopy = await getContentById(sourcePageId, 'space,body.storage,children.page,metadata.labels');\n  if (templateProcessor.isApplicableTemplatePage(pageToCopy)) {\n    await templateProcessor.transformPage(pageToCopy);\n\n    // Create the new page under targetSpaceKey:targetPageId\n    var copiedPage = await createPageUnderPageId(pageToCopy,targetSpaceKey,targetPageId);\n    copiedPages.push(copiedPage);\n    return await copyAllChildren(pageToCopy, targetSpaceKey, copiedPage.id, templateProcessor, copiedPages);\n  } else {\n    console.log(\"Page is not a template, not copied, but children will be copied: \",pageToCopy.title);\n    return await copyAllChildren(pageToCopy, targetSpaceKey, targetPageId, templateProcessor, copiedPages);\n  }\n}\n\nexport async function copyAllChildren(pageToCopy, targetSpaceKey, targetPageId, templateProcessor, copiedPages) {\n  // recursively copy all children\n  var copiedChildren = [];\n  console.log(\"In copyAllChildren\", pageToCopy,targetPageId);\n  if (pageToCopy.children && pageToCopy.children.page && pageToCopy.children.page.results) {\n    for (let child of pageToCopy.children.page.results) {\n      copiedChildren.push(await copyPageRecursiveInternal(child.id, targetSpaceKey, targetPageId, templateProcessor, copiedPages));\n    }\n  }\n  return copiedChildren;\n}\n\nexport async function createPage(page, targetSpaceKey, targetParentTitle) {\n  var targetParentPage = await getContent(targetSpaceKey,targetParentTitle,'space');\n  console.log(\"targetParentPage: space=\",targetParentPage.space.key, \"id=\", targetParentPage.id, \"title=\", targetParentPage.title);\n  return await createPageUnderPageId(page, targetParentPage.space.key, targetParentPage.id);\n}\n\nexport async function createPageUnderPageId(page, targetSpaceKey, targetPageId) {\n  page.ancestors=[ { id: targetPageId } ];\n  console.log(\"New Page\",page);\n  page.space={ key: targetSpaceKey };\n  return await postPage(page);\n}\n\nexport async function postPage(page) {\n  return await throttleWrite( async () => await $.ajax(\n    {\n      url: '/rest/api/content',\n      type: 'POST',\n      contentType: 'application/json',\n      data: JSON.stringify(page)\n    }\n  ));\n}\n\nexport async function updateContent(page) {\n  return await throttleWrite( async () => await $.ajax(\n    {\n      url: '/rest/api/content/'+encodeURIComponent(page.id),\n      type: 'PUT',\n      contentType: 'application/json',\n      data: JSON.stringify(page)\n    }\n  ));\n}\n\nexport async function getPageTree( pageId, parentId, parentTitle, counter ) {\n  console.log(`Queueing getContentById for ${pageId}`);\n  var pageAndChildren = await throttleRead(() => getContentById(pageId, 'history.lastUpdated,children.page,metadata.labels'));\n  counter.pages++;\n  if (counter.pages%100 == 0) console.log(`Found ${counter.pages} pages so far...`);\n  var childrenP = [];\n  var childrenPages = pageAndChildren.children.page;\n  while (childrenPages && childrenPages.size>0) {\n    for (let child of childrenPages.results) {\n      childrenP.push(getPageTree(child.id, pageId, pageAndChildren.title, counter));\n    }\n    // get next page if any\n    if (childrenPages._links.next) {\n      console.log(`Queueing GET next page of children for ${pageAndChildren.title}: ${childrenPages._links.next}`);\n      childrenPages = await throttleRead(() => $.ajax(childrenPages._links.next));\n    } else {\n      childrenPages=false;\n    }\n  }\n\n  return {\n    title: pageAndChildren.title,\n    id: pageId,\n    lastUpdated: new Date(pageAndChildren.history.lastUpdated.when),\n    createdDate: new Date(pageAndChildren.history.createdDate),\n    parentId: parentId,\n    parentTitle: parentTitle,\n    children: await Promise.all(childrenP),\n    labels: Array.prototype.map.call(pageAndChildren.metadata.labels.results, l=>l.name)\n  };\n}","const MAX_PARALLEL_READ = 3;\nconst MAX_PARALLEL_WRITE = 1;\nexport const throttleRead = require('throat')(MAX_PARALLEL_READ);\nexport const throttleWrite = require('throat')(MAX_PARALLEL_WRITE);\n","import {getContentById, getContent, createPageUnderPageId} from './confluence-page-async';\nimport {cloneAttachment} from './confluence-attachment-async';\n\nexport async function syncPageToSpace(sourcePageId, targetSpaceKey, targetParentId, syncAttachments) {\n    let pageToCopy = await getContentById(sourcePageId, 'space,body.storage,metadata.labels,children.attachment');\n    let targetPage;\n    try {\n      targetPage = await getContent(targetSpaceKey, pageToCopy.title);\n      // TODO update the body if modified\n    } catch (err) {\n      // Create the new page \n      targetPage = await createPageUnderPageId(pageToCopy,targetSpaceKey,targetParentId);\n    }\n    if (syncAttachments) {\n      let synced = await syncAttachmentsToContainer(pageToCopy.children.attachment, targetPage.id);\n      console.log(`${synced.length} attachments synced for ${pageToCopy.title}`);\n    }\n    return targetPage;\n}\n\nasync function syncAttachmentsToContainer(attachments, targetContainerId) {\n  const synced = [];\n  for (let attachment of attachments.results) {\n    synced.push(await cloneAttachment(attachment, targetContainerId) );\n  }\n  if (attachments._links.next) {\n    console.log(\"More than 25 attachments, loading next page\");\n    let nextBatch = await syncAttachmentsToContainer(await $.get(attachments._links.next), targetContainerId);\n    return [].concat(synced, nextBatch);\n  } else {\n    return synced;\n  }\n}","import {syncPageToSpace} from '../common/confluence/content-sync-service';\nimport {getContent} from '../common/confluence/confluence-page-async';\n\n/*\n\nSource Space Key: <input id=\"sourceSpaceKey\" value=\"ps\" /><br>\nTarget Space Key: <input id=\"targetSpaceKey\" value=\"~adrien.missemer@hybris.com\" /><br>\nTarget Parent Page: <input id=\"targetParentPage\" value=\"Tests\" /><br>\nSource Page Title: <input id=\"sourcePageTitle\" value=\"Test Adrien With Attachments\" /><br>\n<input type=\"button\" id=\"copyBtn\" value=\"Copy\"/>\n<br>\n<textarea id=\"output\" style=\"width: 100%; height: 100px;\"></textarea>\n<br>\nResult page: \n<div id=\"resultPage\"></div>\n<script src=\"http://localhost/ywiki-plugins/dist/space-sync-bundle.js\"></script>\n*/\nconsole.log(\"jquery binding\");\n$(\"#copyBtn\").click(async () => {\n    try {\n        let sourceSpaceKey = $(\"#sourceSpaceKey\").val();\n        let targetSpaceKey = $(\"#targetSpaceKey\").val();\n        let targetParentPage = $(\"#targetParentPage\").val();\n        let sourcePageTitle = $(\"#sourcePageTitle\").val();\n        output();\n        output(`Syncing ${sourcePageTitle} to ${targetSpaceKey}...`);\n        let sourcePage = await getContent(sourceSpaceKey,sourcePageTitle);\n        let targetParent = await getContent(targetSpaceKey,targetParentPage);\n        let syncedPage = await syncPageToSpace(sourcePage.id, targetSpaceKey, targetParent.id, true);\n        output(\"Done\");\n        $(\"#resultPage\").html(`<a href=\"https://wiki.hybris.com/pages/viewpage.action?pageId=${syncedPage.id}\">${syncedPage.title}</a>`);\n    } catch (err) {\n        output(err);\n    }\n});\n\nconst OUT = $(\"#output\");\n\nfunction output(txt) {\n    if (txt === undefined || txt === null) {\n        OUT.text(\"\");\n    } else {\n        OUT.text(OUT.text() + txt + '\\n');\n    }\n}","'use strict';\n\nmodule.exports = function (PromiseArgument) {\n  var Promise;\n  function throat(size, fn) {\n    var queue = new Queue();\n    function run(fn, self, args) {\n      if (size) {\n        size--;\n        var result = new Promise(function (resolve) {\n          resolve(fn.apply(self, args));\n        });\n        result.then(release, release);\n        return result;\n      } else {\n        return new Promise(function (resolve) {\n          queue.push(new Delayed(resolve, fn, self, args));\n        });\n      }\n    }\n    function release() {\n      size++;\n      if (!queue.isEmpty()) {\n        var next = queue.shift();\n        next.resolve(run(next.fn, next.self, next.args));\n      }\n    }\n    if (typeof size === 'function') {\n      var temp = fn;\n      fn = size;\n      size = temp;\n    }\n    if (typeof size !== 'number') {\n      throw new TypeError(\n        'Expected throat size to be a number but got ' + typeof size\n      );\n    }\n    if (fn !== undefined && typeof fn !== 'function') {\n      throw new TypeError(\n        'Expected throat fn to be a function but got ' + typeof fn\n      );\n    }\n    if (typeof fn === 'function') {\n      return function () {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n        return run(fn, this, args);\n      };\n    } else {\n      return function (fn) {\n        if (typeof fn !== 'function') {\n          throw new TypeError(\n            'Expected throat fn to be a function but got ' + typeof fn\n          );\n        }\n        var args = [];\n        for (var i = 1; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n        return run(fn, this, args);\n      };\n    }\n  }\n  if (arguments.length === 1 && typeof PromiseArgument === 'function') {\n    Promise = PromiseArgument;\n    return throat;\n  } else {\n    Promise = module.exports.Promise;\n    if (typeof Promise !== 'function') {\n      throw new Error(\n        'You must provide a Promise polyfill for this library to work in older environments'\n      );\n    }\n    return throat(arguments[0], arguments[1]);\n  }\n};\n\n/* istanbul ignore next */\nif (typeof Promise === 'function') {\n  module.exports.Promise = Promise;\n}\n\nfunction Delayed(resolve, fn, self, args) {\n  this.resolve = resolve;\n  this.fn = fn;\n  this.self = self || null;\n  this.args = args;\n}\n\nfunction Queue() {\n  this._s1 = [];\n  this._s2 = [];\n}\n\nQueue.prototype.push = function (value) {\n  this._s1.push(value);\n};\n\nQueue.prototype.shift = function () {\n  var s2 = this._s2;\n  if (s2.length === 0) {\n    var s1 = this._s1;\n    if (s1.length === 0) {\n      return;\n    }\n    this._s1 = s2;\n    s2 = this._s2 = s1.reverse();\n  }\n  return s2.pop();\n};\n\nQueue.prototype.isEmpty = function () {\n  return !this._s1.length && !this._s2.length;\n};\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChNA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}