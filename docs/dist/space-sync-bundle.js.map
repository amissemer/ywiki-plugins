{"version":3,"file":"space-sync-bundle.js","sources":["webpack:///webpack/bootstrap","webpack:///./js/common/config.js","webpack:///./js/common/confluence/confluence-attachment-async.js","webpack:///./js/common/confluence/confluence-page-async.js","webpack:///./js/common/confluence/confluence-properties-async.js","webpack:///./js/common/confluence/confluence-properties-service.js","webpack:///./js/common/confluence/confluence-throttle.js","webpack:///./js/common/confluence/content-sync-service.js","webpack:///./js/mainframe/spaceSyncPlugin.js","webpack:///./node_modules/throat/index.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/ywiki-plugins/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./js/mainframe/spaceSyncPlugin.js\");\n","export const DEFAULT_JIRA_COLUMNS = 'key,summary,created,priority,status';\nexport const DEFAULT_JIRA_ISSUE_COUNT = 10;\nexport const MAIN_JIRA_LABEL = \"CI\";\nexport const TAGS_FIELD = \"customfield_10032\";\nexport const WIKI_HOST = 'wiki.hybris.com';\nexport const MAX_WIKI_PAGE_CREATION_RATE = 50; // (in millis) The wiki seems to have trouble handling too fast page creations, when there are more than 10 of them or so, so we are limiting the rate\nexport const SINGLE_WORKSPACE_PAGE_REDIRECT_DELAY = 500; // (in millis) for ESPLM-846\nexport const PREFIX = \"ywiki-plugins.\";\nexport const PREFERRED_REGION_KEY = \"preferred.region\";\nexport const DEFAULT_PROJECT_DOCUMENTATION_ROOT_PAGE = 'Project Documentation';\nexport const CISTATS_DATA_PAGE = 'Continuous Improvement - The Golden Button';\nexport const DEFAULT_CUSTOMER_PAGE_TEMPLATE = '.CI New Project Documentation Template';\nexport const XSLT_ENDPOINT_URL = 'https://bzycrip1eh.execute-api.eu-central-1.amazonaws.com/dev/page/transform';\n// export const WIKI_HOST = 'performancewiki2.hybris.com';\nexport const PROP_KEY = 'ysync';","import {throttleRead, throttleWrite} from './confluence-throttle';\n\nconst BASE_URL = '/rest/api/content/';\n\nexport async function cloneAttachment(attachment, targetContainerId, syncTimeStamp) {\n    let targetAttachment = await lookupAttachment(targetContainerId, attachment.title);\n    let targetAttachmentId = targetAttachment ? targetAttachment.id:null;\n    if (syncTimeStamp && targetAttachmentId!=null && (targetAttachmentId !== syncTimeStamp.targetContentId || targetAttachment.version.number !== syncTimeStamp.targetVersion ) ) {\n        throw `Attachment ${targetAttachmentId} was modified on target, should we overwrite?`;\n    }\n    if (syncTimeStamp && targetAttachmentId!=null && attachment.version.number === syncTimeStamp.sourceVersion) {\n        console.log(`attachment ${targetAttachmentId} was already up-to-date, synced with source version ${attachment.version.number}`);\n        return targetAttachment;\n    } else {\n        return clone(attachment._links.download, targetContainerId, attachment.title, targetAttachmentId);\n    }\n}\n\nasync function lookupAttachment(containerId, attachmentTitle) {\n    let results = await $.get(BASE_URL+`${containerId}/child/attachment?filename=${attachmentTitle}&expand=space,version,container`);\n    if (results && results.results && results.results.length) {\n        return results.results[0];\n    } else {\n        return null;\n    }\n}\n\nasync function clone(attachmentUrl, targetContainerId, title, /* optional */ targetId) {\n    let blobData = await loadBlob(attachmentUrl);\n    let attachment = JSON.parse(await storeBlob(targetContainerId, blobData, title, targetId));\n    if (attachment.results && attachment.results instanceof Array ) {\n        // the attachment API returns an array\n        attachment = attachment.results[0]; \n    } \n    // populate the space.key to save a GET, since we need it to store the sync timestamp\n    if (!attachment.space) {\n        attachment.space = {\n            key: attachment._expandable.space.replace(/.*\\//,'')\n        };\n    }\n    return attachment;\n}\n\n/** \n * ContentId is mandatory when updating an existing attachment, and must be omitted when\n * creating a new attachment.\n */\nasync function storeBlob(containerId, blobData, title, /* optional */ contentId) {\n    let url = BASE_URL;\n    url += containerId;\n    url += '/child/attachment';\n    if (contentId) {\n        url += '/' + contentId + '/data';\n    }\n    let formData = new FormData();\n    formData.append('file', blobData, title);\n    formData.append('minorEdit', 'true');\n    return throttleWrite( () => postBinary(url, formData));\n}\n\n\n\nasync function loadBlob(url) {\n    return throttleRead( () => loadBinary(url) );\n}\n\nasync function postBinary(url, formData) {\n    return new Promise( (resolve, reject) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", url, true);\n        xhr.onerror = reject;\n        xhr.setRequestHeader('X-Atlassian-Token','nocheck');\n        xhr.onload = function (e) {\n            if (this.status == 200) {\n                resolve(this.response);\n            } else {\n                reject(`Could not POST to ${url}: ${this.status} ${this.statusText}, details: ${this.responseText}`);\n            }\n        };\n        xhr.send(formData);\n    });\n}\nasync function loadBinary(url) {\n    return new Promise( (resolve, reject) => {\n        let xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'blob';\n        xhr.onerror = reject;\n        xhr.onload = function(e) {\n          if (this.status == 200) {\n            // get binary data as a response\n            let blob = this.response;\n            resolve(blob);\n          } else {\n            reject(e);\n          }\n        };\n        xhr.send();\n    });\n}","import {throttleRead, throttleWrite} from './confluence-throttle';\n\nexport async function movePages(sourceSpaceKey, sourcePageTitle,targetSpaceKey, targetParentTitle) {\n  var sourcePage = await getContent(sourceSpaceKey, sourcePageTitle);\n  return await movePagesById( sourcePage.id, targetSpaceKey, targetParentTitle );\n}\nfunction getAtlToken() {\n  return $('meta[name=ajs-atl-token]').attr(\"content\");\n}\n\nexport async function movePagesById (sourcePageId, targetSpaceKey, target) {\n  return await throttleWrite( async () => {\n    let targetParentTitle;\n    if (Number.isInteger(Number(target))) {\n      let targetParent = await getContentById(Number(target));\n      targetParentTitle = targetParent.title;\n    } else {\n      targetParentTitle = target;\n    }\n    if (!targetParentTitle) throw 'targetParentTitle is mandatory (for source '+sourcePageId+' and target '+target+')';\n    var url = '/pages/movepage.action?pageId='+encodeURIComponent(sourcePageId)+'&spaceKey='+encodeURIComponent(targetSpaceKey)+'&targetTitle='+encodeURIComponent(targetParentTitle)+'&position=append&atl_token='+getAtlToken()+'&_='+Math.random();\n    console.log(\"Moving page \",sourcePageId,\" under \",targetSpaceKey+\":\"+ targetParentTitle, url);\n    let resp = await $.ajax(url);\n    if (typeof resp === 'string' && resp.indexOf('Not Permitted'>=0)) {\n      throw 'Not Permitted';\n    } else if (typeof resp === 'string') {\n      throw 'Generic move error';\n    } else if (resp.actionErrors) {\n      throw resp.actionErrors.join();\n    }\n  });\n}\n\n\n\n/**\n* Get a page by spaceKey and title from Confluence and returns a deferred for that page.\n* See $.ajax().done()\n* Failures are logged and ignored.\n* The deferred is resolved with the first matching page is any, else it is rejected.\n*/\nexport async function getContent(spaceKey,pageTitle,expand) {\n  var expandParam=\"\";\n  if (expand) {\n    expandParam = '&expand='+encodeURIComponent(expand);\n  }\n  var url = '/rest/api/content?type=page&spaceKey='+encodeURIComponent(spaceKey)+'&limit=1&title=' + encodeURIComponent(pageTitle) + expandParam;\n  console.log(\"Getting page content from \" + url);\n  var response = await $.ajax(url);\n  console.log(\"Filtering AJAX response\",response);\n  if (response.results && response.results.length>0) {\n    var page = response.results[0];\n    console.log(\"Returning \",page);\n    return page;\n  } else {\n    throw \"Page Not found: '\"+spaceKey+\":\"+pageTitle+\"'\";\n  }\n}\n\nexport async function getContentById(pageId, expand) {\n  var expandParam=\"\";\n  if (expand) {\n    expandParam = '?expand='+encodeURIComponent(expand);\n  }\n  var url = '/rest/api/content/'+encodeURIComponent(pageId) + expandParam;\n  console.log(url);\n  return await $.ajax(url);\n}\n \n/** search for content with CQL\nfor example https://wiki.hybris.com/rest/api/content/search?cql=label=customer%20and%20type=%22page%22%20and%20space=%22ps%22 */\nexport async function searchPagesWithCQL(spaceKey, cqlQuery, limit, expand) {\n  if (!limit || limit<0) {\n    limit=15;\n  }\n  var expandParam=(expand?\"&expand=\"+encodeURIComponent(expand):\"\");\n  return await $.ajax('/rest/api/content/search?limit='+encodeURIComponent(limit)+'&cql='+encodeURIComponent(cqlQuery+' and type=page and space=\\''+spaceKey+'\\'')+expandParam);\n}\n\n/**\n* Copy the page \"fromPageTitle\" (without its descendants) under the page \"toPageTitle\",\n* and do a placeholder replacement the page title using the templateProcessor.\n*/\nexport async function copyPage(fromSpaceKey, fromPageTitle, toSpaceKey, toPageTitle, templateProcessor) {\n  var pageToCopy = await getContent(fromSpaceKey, fromPageTitle, 'space,body.storage,metadata.labels');\n  await templateProcessor.transformPage(pageToCopy);\n  // Create the new page under toPageTitle\n  return await createPage(pageToCopy,toSpaceKey,toPageTitle);\n}\n\nexport async function copyPageToSpace(sourcePageId, targetSpaceKey, targetParentId) {\n  let pageToCopy = await getContentById(sourcePageId, 'space,body.storage,metadata.labels');\n  try {\n    return await getContent(targetSpaceKey, pageToCopy.title);\n    // if it exists, do nothing\n  } catch (err) {\n    // Create the new page \n    return await createPageUnderPageId(pageToCopy,targetSpaceKey,targetParentId);\n  }\n}\n\nexport async function createPageFromTemplate(templateSpace, templateTitle, targetSpaceKey, targetPageId, templateProcessor) {\n  var pageToCopy = await getContent(templateSpace, templateTitle, 'space,body.storage,metadata.labels');\n  //var parentPage = await getContentById(targetPageId, 'space');\n  await templateProcessor.transformPage(pageToCopy);\n  // Create the new page under toPageTitle\n  return await createPageUnderPageId(pageToCopy,targetSpaceKey,targetPageId);\n}\n\nexport async function copyPageRecursive(fromSpaceKey, fromPageTitle, toSpaceKey, toPageTitle, templateProcessor, copiedPages) {\n  var sourcePagePromise = getContent(fromSpaceKey, fromPageTitle);\n  var targetPagePromise = getContent(toSpaceKey,toPageTitle, 'space');\n  var pages = await Promise.all(sourcePagePromise,targetPagePromise);\n  return await copyPageRecursiveInternal( pages[0].id, pages[1].space.key, pages[1].id, templateProcessor, copiedPages);\n}\n\nexport async function copyPageRecursiveInternal(sourcePageId, targetSpaceKey, targetPageId, templateProcessor, copiedPages) {\n  var pageToCopy = await getContentById(sourcePageId, 'space,body.storage,children.page,metadata.labels');\n  if (templateProcessor.isApplicableTemplatePage(pageToCopy)) {\n    await templateProcessor.transformPage(pageToCopy);\n\n    // Create the new page under targetSpaceKey:targetPageId\n    var copiedPage = await createPageUnderPageId(pageToCopy,targetSpaceKey,targetPageId);\n    copiedPages.push(copiedPage);\n    return await copyAllChildren(pageToCopy, targetSpaceKey, copiedPage.id, templateProcessor, copiedPages);\n  } else {\n    console.log(\"Page is not a template, not copied, but children will be copied: \",pageToCopy.title);\n    return await copyAllChildren(pageToCopy, targetSpaceKey, targetPageId, templateProcessor, copiedPages);\n  }\n}\n\nexport async function copyAllChildren(pageToCopy, targetSpaceKey, targetPageId, templateProcessor, copiedPages) {\n  // recursively copy all children\n  var copiedChildren = [];\n  console.log(\"In copyAllChildren\", pageToCopy,targetPageId);\n  if (pageToCopy.children && pageToCopy.children.page && pageToCopy.children.page.results) {\n    for (let child of pageToCopy.children.page.results) {\n      copiedChildren.push(await copyPageRecursiveInternal(child.id, targetSpaceKey, targetPageId, templateProcessor, copiedPages));\n    }\n  }\n  return copiedChildren;\n}\n\nexport async function createPage(page, targetSpaceKey, targetParentTitle) {\n  var targetParentPage = await getContent(targetSpaceKey,targetParentTitle,'space');\n  console.log(\"targetParentPage: space=\",targetParentPage.space.key, \"id=\", targetParentPage.id, \"title=\", targetParentPage.title);\n  return await createPageUnderPageId(page, targetParentPage.space.key, targetParentPage.id);\n}\n\nexport async function createPageUnderPageId(page, targetSpaceKey, targetPageId) {\n  page.ancestors=[ { id: targetPageId } ];\n  console.log(\"New Page\",page);\n  page.space={ key: targetSpaceKey };\n  return await postPage(page);\n}\n\nexport async function postPage(page) {\n  return await throttleWrite( async () => await $.ajax(\n    {\n      url: '/rest/api/content',\n      type: 'POST',\n      contentType: 'application/json',\n      data: JSON.stringify(page)\n    }\n  ));\n}\n\nexport async function updateContent(page) {\n  return await throttleWrite( async () => await $.ajax(\n    {\n      url: '/rest/api/content/'+encodeURIComponent(page.id),\n      type: 'PUT',\n      contentType: 'application/json',\n      data: JSON.stringify(page)\n    }\n  ));\n}\n\nexport async function getPageTree( pageId, parentId, parentTitle, counter ) {\n  console.log(`Queueing getContentById for ${pageId}`);\n  var pageAndChildren = await throttleRead(() => getContentById(pageId, 'history.lastUpdated,children.page,metadata.labels'));\n  counter.pages++;\n  if (counter.pages%100 == 0) console.log(`Found ${counter.pages} pages so far...`);\n  var childrenP = [];\n  var childrenPages = pageAndChildren.children.page;\n  while (childrenPages && childrenPages.size>0) {\n    for (let child of childrenPages.results) {\n      childrenP.push(getPageTree(child.id, pageId, pageAndChildren.title, counter));\n    }\n    // get next page if any\n    if (childrenPages._links.next) {\n      console.log(`Queueing GET next page of children for ${pageAndChildren.title}: ${childrenPages._links.next}`);\n      childrenPages = await throttleRead(() => $.ajax(childrenPages._links.next));\n    } else {\n      childrenPages=false;\n    }\n  }\n\n  return {\n    title: pageAndChildren.title,\n    id: pageId,\n    lastUpdated: new Date(pageAndChildren.history.lastUpdated.when),\n    createdDate: new Date(pageAndChildren.history.createdDate),\n    parentId: parentId,\n    parentTitle: parentTitle,\n    children: await Promise.all(childrenP),\n    labels: Array.prototype.map.call(pageAndChildren.metadata.labels.results, l=>l.name)\n  };\n}","import {throttleRead, throttleWrite} from './confluence-throttle';\n\nconst BASE_URL = '/rest/api/content/';\n\nexport async function load(contentId, key)  {\n    let url = BASE_URL + `${contentId}/property/${key}`; \n    return $.get(url);\n}\n\nexport async function create(contentId, propertyData)  {\n    let url = BASE_URL + `${contentId}/property`; \n    return $.ajax({\n        url: url, \n        contentType: \"application/json;charset=UTF-8\",\n        type: \"POST\",\n        data: JSON.stringify( propertyData )\n    });\n}\n\nexport async function update(contentId, propertyData)  {\n    let url = BASE_URL + `${contentId}/property/${propertyData.key}`; \n    return $.ajax({\n        url: url, \n        contentType: \"application/json;charset=UTF-8\",\n        type: \"PUT\",\n        data: JSON.stringify( propertyData )\n    });\n}\n","import {create,load,update} from './confluence-properties-async';\n\nexport async function getPropertyValue(contentId, key) {\n    try {\n        return (await load(contentId, key)).value;\n    } catch (err) {\n        return null;\n    }\n}\n\nexport async function setPropertyValue(contentId, key, value) {\n    let propertyData = {\n        id: null,\n        key: key,\n        version: {\n            minorEdit: true,\n            number: null\n        },\n        value: value\n    };\n\n    try {\n        let existingProperty = await load(contentId, key);\n        propertyData.id = existingProperty.id;\n        propertyData.version.number = existingProperty.version.number+1;\n    } catch (err) {\n        // ignore, it just means the property does not exist yet\n    }\n    if (propertyData.id) {\n        update(contentId, propertyData);\n    } else {\n        create(contentId, propertyData);\n    }\n}\n\n/**\n * updateCallback: function(propertyData)=>void\n */\nexport async function doWithPropertyValue(contentId, key, updateCallback) {\n    let propertyData;\n    try {\n        propertyData = await load(contentId, key);\n        propertyData.version.number++;\n    } catch (err) {\n        propertyData = {\n            id: null,\n            key: key,\n            version: {\n                minorEdit: true,\n                number: null\n            },\n            value: {}\n        };\n    }\n    await updateCallback(propertyData.value);\n    if (propertyData.id) {\n        update(contentId, propertyData);\n    } else {\n        create(contentId, propertyData);\n    }\n}\n","const MAX_PARALLEL_READ = 3;\nconst MAX_PARALLEL_WRITE = 1;\nexport const throttleRead = require('throat')(MAX_PARALLEL_READ);\nexport const throttleWrite = require('throat')(MAX_PARALLEL_WRITE);\n","import {getContentById, getContent, createPageUnderPageId, updateContent} from './confluence-page-async';\nimport {cloneAttachment} from './confluence-attachment-async';\nimport {doWithPropertyValue,getPropertyValue} from './confluence-properties-service';\nimport {PROP_KEY} from '../config';\n\n/** \n * Synchronizes a single page between spaces, with or without attachments.\n * If the page doesn't exist in the target, it is created under targetParentId.\n */\nexport async function syncPageToSpace(sourcePageId, targetSpaceKey, targetParentId, syncAttachments) {\n    let pageToCopy = await getContentById(sourcePageId, 'version,space,body.storage,metadata.labels,children.attachment.version,children.attachment.space');\n    let targetPage;\n    let syncProp = await getPropertyValue(sourcePageId, PROP_KEY);\n    if (syncProp && syncProp.syncTargets && syncProp.syncTargets[targetSpaceKey]) {\n      let syncTimeStamp = syncProp.syncTargets[targetSpaceKey];\n      try {\n        targetPage = await getContentById(syncTimeStamp.targetContentId, 'version,metadata.labels');\n        // TODO filter links\n        await updateContentIfNecessary(pageToCopy, targetPage, syncTimeStamp);\n      } catch (err) {\n        // the last synced target page was removed, we will recreate\n      }\n    }\n    if (!targetPage) {\n      try {\n        targetPage = await getContent(targetSpaceKey, pageToCopy.title, 'version,metadata.labels');\n        // Do a full initial sync\n        // TODO filter links\n        await updateContentIfNecessary(pageToCopy, targetPage);\n      } catch (err) {\n        // Create the new page \n        // TODO filter links\n        targetPage = await createPageUnderPageId(pageToCopy,targetSpaceKey,targetParentId);\n      }\n    }\n    await setSyncTimeStamps(pageToCopy, targetPage, pageToCopy.space.key, targetSpaceKey);\n\n    if (syncAttachments) {\n      let synced = await syncAttachmentsToContainer(pageToCopy.children.attachment, targetPage.id, targetSpaceKey);\n      console.log(`${synced.length} attachments synced for ${pageToCopy.title}`);\n    }\n\n    return targetPage;\n}\n\nasync function updateContentIfNecessary(sourcePage, targetPage, syncTimeStamp) {\n  if (syncTimeStamp && targetPage.version.number !== syncTimeStamp.targetVersion) {\n    throw `targetPage was modified after sync, should we overwrite? ${targetPage.title}`;\n  }\n  if (syncTimeStamp && sourcePage.version.number === syncTimeStamp.sourceVersion) {\n    console.log(`page ${targetPage.title} was already up-to-date, synced with source version ${sourcePage.version.number}`);\n    // TODO update labels even if not modified\n  } else {\n    targetPage.version.number++;\n    targetPage.body = targetPage.body || {};\n    targetPage.body.storage = sourcePage.body.storage; // TODO filtering\n    targetPage.title = sourcePage.title;\n    targetPage.metadata.labels = sourcePage.metadata.labels;\n    await updateContent(targetPage);\n  }\n}\n\nasync function setSyncTimeStamps(srcContent, targetContent, souceSpace, targetSpace) {\n  let syncTime = new Date();\n  let syncTimeStamp = {\n    sourceContentId : srcContent.id,\n    targetContentId : targetContent.id,\n    sourceVersion: srcContent.version.number,\n    targetVersion: targetContent.version.number,\n    syncTime: syncTime\n  };\n  await doWithPropertyValue(srcContent.id, PROP_KEY, function(value) {\n    if (value.syncTargets) {\n      console.log(\"Previous value on source item: syncTargets: \",value.syncTargets);\n    } else {\n      value.syncTargets = {};\n    }\n    value.syncTargets[targetSpace] = syncTimeStamp;\n  });\n  await doWithPropertyValue(targetContent.id, PROP_KEY, function(value) {\n    if (value.syncSources) {\n      console.log(\"Previous value on target item: syncSources: \",value.syncSources);\n    } else {\n      value.syncSources = {};\n    }\n    value.syncSources[souceSpace] = syncTimeStamp;\n  });\n}\n\nexport async function syncSubTreeToSpace(sourcePageId, targetSpaceKey) {\n  let subTreeRoot = await getContentById(sourcePageId, 'space,ancestors');\n}\n\nasync function syncAttachmentsToContainer(attachments, targetContainerId, targetSpaceKey) {\n  const synced = [];\n  for (let attachment of attachments.results) {\n\n    let syncProp = await getPropertyValue(attachment.id, PROP_KEY);\n    let syncTimeStamp=null;\n    if (syncProp && syncProp.syncTargets && syncProp.syncTargets[targetSpaceKey]) {\n      syncTimeStamp = syncProp.syncTargets[targetSpaceKey];\n    }\n    let cloned = await cloneAttachment(attachment, targetContainerId, syncTimeStamp);\n    await setSyncTimeStamps(attachment, cloned, attachment.space.key, cloned.space.key);\n    synced.push(cloned);\n  }\n  if (attachments._links.next) {\n    console.log(\"More than 25 attachments, loading next page\");\n    let nextBatch = await syncAttachmentsToContainer(await $.get(attachments._links.next + \"&expand=space,version\"), targetContainerId, targetSpaceKey);\n    return [].concat(synced, nextBatch);\n  } else {\n    return synced;\n  }\n}","import {syncPageToSpace} from '../common/confluence/content-sync-service';\nimport {getContent} from '../common/confluence/confluence-page-async';\n\n/*\n\nSource Space Key: <input id=\"sourceSpaceKey\" value=\"ps\" /><br>\nTarget Space Key: <input id=\"targetSpaceKey\" value=\"~adrien.missemer@hybris.com\" /><br>\nTarget Parent Page: <input id=\"targetParentPage\" value=\"Tests\" /><br>\nSource Page Title: <input id=\"sourcePageTitle\" value=\"Test Adrien With Attachments\" /><br>\n<input type=\"button\" id=\"copyBtn\" value=\"Copy\"/>\n<br>\n<textarea id=\"output\" style=\"width: 100%; height: 100px;\"></textarea>\n<br>\nResult page: \n<div id=\"resultPage\"></div>\n<script src=\"http://localhost/ywiki-plugins/dist/space-sync-bundle.js\"></script>\n*/\nconsole.log(\"jquery binding\");\n$(\"#copyBtn\").click(async () => {\n    try {\n        let sourceSpaceKey = $(\"#sourceSpaceKey\").val();\n        let targetSpaceKey = $(\"#targetSpaceKey\").val();\n        let targetParentPage = $(\"#targetParentPage\").val();\n        let sourcePageTitle = $(\"#sourcePageTitle\").val();\n        output();\n        output(`Syncing ${sourcePageTitle} to ${targetSpaceKey}...`);\n        let sourcePage = await getContent(sourceSpaceKey,sourcePageTitle);\n        let targetParent = await getContent(targetSpaceKey,targetParentPage);\n        let syncedPage = await syncPageToSpace(sourcePage.id, targetSpaceKey, targetParent.id, true);\n        output(\"Done\");\n        $(\"#resultPage\").html(`<a href=\"https://wiki.hybris.com/pages/viewpage.action?pageId=${syncedPage.id}\">${syncedPage.title}</a>`);\n    } catch (err) {\n        output(err);\n    }\n});\n\nconst OUT = $(\"#output\");\n\nfunction output(txt) {\n    if (txt === undefined || txt === null) {\n        OUT.text(\"\");\n    } else {\n        OUT.text(OUT.text() + txt + '\\n');\n    }\n}","'use strict';\n\nmodule.exports = function (PromiseArgument) {\n  var Promise;\n  function throat(size, fn) {\n    var queue = new Queue();\n    function run(fn, self, args) {\n      if (size) {\n        size--;\n        var result = new Promise(function (resolve) {\n          resolve(fn.apply(self, args));\n        });\n        result.then(release, release);\n        return result;\n      } else {\n        return new Promise(function (resolve) {\n          queue.push(new Delayed(resolve, fn, self, args));\n        });\n      }\n    }\n    function release() {\n      size++;\n      if (!queue.isEmpty()) {\n        var next = queue.shift();\n        next.resolve(run(next.fn, next.self, next.args));\n      }\n    }\n    if (typeof size === 'function') {\n      var temp = fn;\n      fn = size;\n      size = temp;\n    }\n    if (typeof size !== 'number') {\n      throw new TypeError(\n        'Expected throat size to be a number but got ' + typeof size\n      );\n    }\n    if (fn !== undefined && typeof fn !== 'function') {\n      throw new TypeError(\n        'Expected throat fn to be a function but got ' + typeof fn\n      );\n    }\n    if (typeof fn === 'function') {\n      return function () {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n        return run(fn, this, args);\n      };\n    } else {\n      return function (fn) {\n        if (typeof fn !== 'function') {\n          throw new TypeError(\n            'Expected throat fn to be a function but got ' + typeof fn\n          );\n        }\n        var args = [];\n        for (var i = 1; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n        return run(fn, this, args);\n      };\n    }\n  }\n  if (arguments.length === 1 && typeof PromiseArgument === 'function') {\n    Promise = PromiseArgument;\n    return throat;\n  } else {\n    Promise = module.exports.Promise;\n    if (typeof Promise !== 'function') {\n      throw new Error(\n        'You must provide a Promise polyfill for this library to work in older environments'\n      );\n    }\n    return throat(arguments[0], arguments[1]);\n  }\n};\n\n/* istanbul ignore next */\nif (typeof Promise === 'function') {\n  module.exports.Promise = Promise;\n}\n\nfunction Delayed(resolve, fn, self, args) {\n  this.resolve = resolve;\n  this.fn = fn;\n  this.self = self || null;\n  this.args = args;\n}\n\nfunction Queue() {\n  this._s1 = [];\n  this._s2 = [];\n}\n\nQueue.prototype.push = function (value) {\n  this._s1.push(value);\n};\n\nQueue.prototype.shift = function () {\n  var s2 = this._s2;\n  if (s2.length === 0) {\n    var s1 = this._s1;\n    if (s1.length === 0) {\n      return;\n    }\n    this._s1 = s2;\n    s2 = this._s2 = s1.reverse();\n  }\n  return s2.pop();\n};\n\nQueue.prototype.isEmpty = function () {\n  return !this._s1.length && !this._s2.length;\n};\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}